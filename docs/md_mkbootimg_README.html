<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Garbage OS: BOOTBOOT Bootable Disk Image Creator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Garbage OS
   </div>
   <div id="projectbrief">Operating System Proof of Concept with a built in Garbage Collector Service</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">BOOTBOOT Bootable Disk Image Creator </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>See <a href="https://gitlab.com/bztsrc/bootboot">BOOTBOOT Protocol</a> for common details.</p>
<p>This is an all-in-one, multiplatform, dependency-free disk image creator tool. You pass a disk configuration to it in a very flexible JSON, and it generates ESP FAT boot partition with the required loader files, GPT partitioning table, PMBR, etc. It also creates an initrd or a disk partition from a directory. Supported file systems:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Format </th><th class="markdownTableHeadNone">Initrd </th><th class="markdownTableHeadNone">Partition </th><th class="markdownTableHeadNone">Specification, source  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>jamesm</code> </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone">✗No </td><td class="markdownTableBodyNone"><a href="http://jamesmolloy.co.uk/tutorial_html/8.-The%20VFS%20and%20the%20initrd.html">James Molloy's tutorials</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>cpio</code> </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone">✗No </td><td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Cpio">wikipedia</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>tar</code> </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone"><a href="https://wiki.osdev.org/USTAR">wikipedia</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>echfs</code> </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone"><a href="https://gitlab.com/bztsrc/bootboot/blob/binaries/specs/echfs.md">spec</a>, <a href="https://github.com/echfs/echfs">source</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>FS/Z</code> </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone"><a href="https://gitlab.com/bztsrc/bootboot/raw/binaries/specs/fsz.pdf">spec</a>, <a href="https://gitlab.com/bztsrc/bootboot/blob/master/mkbootimg/fsZ.h">source</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>boot</code> </td><td class="markdownTableBodyNone">✗No </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone"><a href="https://gitlab.com/bztsrc/bootboot/raw/binaries/specs/efifat.pdf">spec</a> (ESP only, 8+3 names)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>fat</code> </td><td class="markdownTableBodyNone">✗No </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone"><a href="https://gitlab.com/bztsrc/bootboot/raw/binaries/specs/vfat.pdf">spec</a> (non-ESP only, with LFN)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>minix</code> </td><td class="markdownTableBodyNone">✗No </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone"><a href="https://gitlab.com/bztsrc/bootboot/raw/binaries/specs/minix.pdf">V2 spec</a>, <a href="https://github.com/Stichting-MINIX-Research-Foundation/minix/tree/master/minix/fs/mfs">V3 source</a> (V3 supported, but there's only V2 spec)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ext2</code> </td><td class="markdownTableBodyNone">✗No </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone"><a href="https://gitlab.com/bztsrc/bootboot/raw/binaries/specs/ext2.pdf">spec</a>, <a href="https://www.nongnu.org/ext2-doc/ext2.html">documentation</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>lean</code> </td><td class="markdownTableBodyNone">✗No </td><td class="markdownTableBodyNone">✔Yes </td><td class="markdownTableBodyNone"><a href="http://freedos-32.sourceforge.net/lean/specification.php">V0.6 spec</a>, <a href="http://www.fysnet.net/leanfs/specification.php">V0.7 spec</a>  </td></tr>
</table>
<p>The code is written in a way that it is easily expandable.</p>
<p>The generated image was tested with fdisk, and with the verify function of gdisk. The FAT partition was tested with fsck.vfat and with TianoCore UEFI firmware and on Raspberry Pi. The ISO9660 part tested with iat (ISO9660 Analyzer Tool) and Linux mount.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Operating Modes</h1>
<div class="fragment"><div class="line">$ ./mkbootimg</div>
<div class="line">BOOTBOOT mkbootimg utility - bztsrc@gitlab</div>
<div class="line"> BOOTBOOT Copyright (c) bzt MIT https://gitlab.com/bztsrc/bootboot</div>
<div class="line"> deflate 1.2.11 Copyright 1995-2017 Jean-loup Gailly and Mark Adler</div>
<div class="line"> Raspbery Pi Firmware Copyright (c) Broadcom Corp, Raspberry Pi (Trading) Ltd</div>
<div class="line"> </div>
<div class="line">Validates ELF or PE executables for being BOOTBOOT compatible, otherwise</div>
<div class="line">creates a bootable hybrid image or Option ROM image for your hobby OS.</div>
<div class="line"> </div>
<div class="line">Usage:</div>
<div class="line">  ./mkbootimg check &lt;kernel elf / pe&gt;</div>
<div class="line">  ./mkbootimg &lt;configuration json&gt; initrd.rom</div>
<div class="line">  ./mkbootimg &lt;configuration json&gt; bootpart.bin</div>
<div class="line">  ./mkbootimg &lt;configuration json&gt; &lt;output disk image name&gt;</div>
<div class="line"> </div>
<div class="line">Examples:</div>
<div class="line">  ./mkbootimg check mykernel/mykernel.x86_64.elf</div>
<div class="line">  ./mkbootimg myos.json initrd.rom</div>
<div class="line">  ./mkbootimg myos.json bootpart.bin</div>
<div class="line">  ./mkbootimg myos.json myos.img</div>
</div><!-- fragment --><p>If the first argument is <code>check</code>, then it's followed by a kernel filename. The utility will check the executable for BOOTBOOT compliance, and it will report all errors and if passed, which BOOTBOOT Protocol level it conforms to.</p>
<p>Otherwise the first argument is the configuration JSON file. If the second argument is <code>initrd.rom</code>, then it will generate a BIOS Option ROM image from the initrd directory. If that is <code>bootpart.bin</code>, then it saves the boot partition image (and only the partition image). Every other filename will make it generate a whole disk image with GPT.</p>
<p>The tool is multilingual. It will detect your operating system's language and if it has a dictionary for it, it will use that. You can override the autodetection from the command line by using the <code>-l &lt;lang&gt;</code> flag as the first argument (available for all operating modes). Language is given in two characters long code and fallbacks to <code>en</code>.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Configuration</h1>
<p>The JSON is simple and flexible, accepts many variations. At the top level, you can define the output disk parameters.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Top Level</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field </th><th class="markdownTableHeadNone">Type </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">diskguid </td><td class="markdownTableBodyNone">GUID </td><td class="markdownTableBodyNone">optional, the disk GUID. If not given, or full zeros, it will be generated  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">disksize </td><td class="markdownTableBodyNone">integer </td><td class="markdownTableBodyNone">optional, the size of the disk image in Megabytes. If not given, it is calculated  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">align </td><td class="markdownTableBodyNone">integer </td><td class="markdownTableBodyNone">optional, the partition alignment in Kilobytes. Zero gives sector alignment  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">iso9660 </td><td class="markdownTableBodyNone">boolean </td><td class="markdownTableBodyNone">optional, wether to generate ISO9660 Boot Catalog into the image. Defaults to false  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">config </td><td class="markdownTableBodyNone">filename </td><td class="markdownTableBodyNone">BOOTBOOT configuration file. It is parsed for the kernel filename  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">initrd </td><td class="markdownTableBodyNone">struct </td><td class="markdownTableBodyNone">the initial ramdisk's definition, see below  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">partitions </td><td class="markdownTableBodyNone">array </td><td class="markdownTableBodyNone">partition definitions, see below  </td></tr>
</table>
<p>Example: </p><div class="fragment"><div class="line">{</div>
<div class="line">    &quot;diskguid&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;,</div>
<div class="line">    &quot;disksize&quot;: 128,</div>
<div class="line">    &quot;align&quot;: 1024,</div>
<div class="line">    &quot;iso9660&quot;: true,</div>
<div class="line">    &quot;config&quot;: &quot;boot/sys/config&quot;,</div>
<div class="line">    &quot;initrd&quot;: { &quot;type&quot;: &quot;tar&quot;, &quot;gzip&quot;: true, &quot;directory&quot;: &quot;boot&quot; },</div>
<div class="line">    &quot;partitions&quot;: [</div>
<div class="line">        { &quot;type&quot;: &quot;boot&quot;, &quot;size&quot;: 16 },</div>
<div class="line">        { &quot;type&quot;: &quot;ext4&quot;, &quot;size&quot;: 128, &quot;name&quot;: &quot;Linux Exchange&quot; },</div>
<div class="line">        { &quot;type&quot;: &quot;ntfs&quot;, &quot;size&quot;: 128, &quot;name&quot;: &quot;Windows Exchange&quot; },</div>
<div class="line">        { &quot;type&quot;: &quot;Microsoft basic data&quot;, &quot;size&quot;: 32, &quot;name&quot;: &quot;MyOS usr&quot;, &quot;file&quot;: &quot;usrpart.bin&quot; },</div>
<div class="line">        { &quot;type&quot;: &quot;00000000-0000-0000-0000-000000000000&quot;, &quot;size&quot;: 32, &quot;name&quot;: &quot;MyOS var&quot;, &quot;file&quot;: &quot;varpart.bin&quot; }</div>
<div class="line">    ]</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
Initrd</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field </th><th class="markdownTableHeadNone">Type </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gzip </td><td class="markdownTableBodyNone">boolean </td><td class="markdownTableBodyNone">optional, wether to compress the initrd image, defaults to true  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">format of the initrd image. When invalid value given, it lists the options  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">file </td><td class="markdownTableBodyNone">filename </td><td class="markdownTableBodyNone">the filename of the image file to be used  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">directory </td><td class="markdownTableBodyNone">folder </td><td class="markdownTableBodyNone">path to a folder, its contents will be used to generate the initrd  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">file </td><td class="markdownTableBodyNone">array </td><td class="markdownTableBodyNone">for multiarch images  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">directory </td><td class="markdownTableBodyNone">array </td><td class="markdownTableBodyNone">for multiarch images  </td></tr>
</table>
<p>The fields <code>file</code> and <code>directory</code> are mutually exclusive. They can be both strings (if there's only one architecture), or arrays (one array element for each architecture). Currently three architecture supported, which means there can be three strings in the arrays. Which architecture is used depends on the kernel's architecture in that folder or image file. Type is only mandatory for <code>directory</code>.</p>
<p>Examples: </p><div class="fragment"><div class="line">&quot;initrd&quot;: { &quot;file&quot;: &quot;initrd.bin&quot; },</div>
<div class="line">&quot;initrd&quot;: { &quot;type&quot;: &quot;tar&quot;, &quot;gzip&quot;: 0, &quot;directory&quot;: &quot;boot&quot; },</div>
<div class="line">&quot;initrd&quot;: { &quot;gzip&quot;: true, &quot;file&quot;: [ &quot;initrd-x86.bin&quot;, &quot;initrd-arm.bin&quot;, &quot;initrd-rv64.bin&quot; ] },</div>
<div class="line">&quot;initrd&quot;: { &quot;type&quot;: &quot;cpio&quot;, &quot;gzip&quot;: true, &quot;directory&quot;: [ &quot;boot/arm&quot;, &quot;boot/x86&quot;, &quot;boot/riscv64&quot; ] },</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28"></a>
Partitions</h2>
<p>It is somewhat unusual, as the first array element is different than the rest. It specifies the boot partition, therefore it has different types, and <code>file</code> / <code>directory</code> and <code>name</code> are not interpreted because that partition image is always dinamically generated with the implicit name of "EFI System Partition". For the same reason, <code>size</code> is mandatory for the first (boot) partition.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field </th><th class="markdownTableHeadNone">Type </th><th class="markdownTableHeadNone">Description  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">size </td><td class="markdownTableBodyNone">integer </td><td class="markdownTableBodyNone">optional, the size of the partition in Megabytes. If not given, it is calculated  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">file </td><td class="markdownTableBodyNone">filename </td><td class="markdownTableBodyNone">optional, path to a partition image to be used  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">directory </td><td class="markdownTableBodyNone">folder </td><td class="markdownTableBodyNone">optional, path to a folder, its contents will be used to generate the partition  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">driver </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">optional, in case type can't specify the format without a doubt  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">type </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">format of the partition. When invalid value given, it lists the options  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">name </td><td class="markdownTableBodyNone">string </td><td class="markdownTableBodyNone">UTF-8 partition names, limited to UNICODE code points 32 to 65535 (BMP)  </td></tr>
</table>
<p>For the first entry, valid values for <code>type</code> are: <code>boot</code> (or explicit <code>fat16</code> and <code>fat32</code>). Generates only 8+3 file names. The utility handles this comfortably, it tries to use FAT16 if possible to save storage space. There's a minimal size for the boot partition, 8 Megabytes. Although both the image creator and BOOTBOOT is capable of handling smaller sizes, some UEFI firmware incorrectly assumes FAT12 when there are too few clusters on the file system. If the partition size is bigger than 128 Megabytes, then it automatically switches to FAT32. If you don't use <code>iso9660</code>, then you can also set FAT32 for smaller images, but at least 33 Megabytes (that's a hard lower limit for FAT32). With <code>iso9660</code>, each cluster must be 2048 bytes aligned, which is achieved by 4 sectors per cluster. The same problem applies here, both the image creator and the BOOTBOOT loader capable of handling FAT32 with smaller cluster numbers, but some UEFI firmware don't, and falsely assumes FAT16. To guarantee the minimum number of clusters, with ISO9660 and FAT32 the boot partition's minimum size is 128 Megabytes (128*1024*1024/512/4 = 65536, just one larger than what fits in 16 bits).</p>
<p>For the other entries (starting from the second), <code>type</code> is either a GUID or one of a pre-defined file system aliases. Here <code>fat</code> will decide between FAT16 and FAT32 based on the number of clusters, and it can generate long file names. With an invalid string, the utility will list all possible values.</p>
<p>Example: </p><div class="fragment"><div class="line">mkbootimg: partition #2 doesn&#39;t have a valid type. Accepted values:</div>
<div class="line">  &quot;65706154-4120-6372-6968-766520465320&quot; / &quot;tar&quot;</div>
<div class="line">  &quot;5A2F534F-0000-5346-2F5A-000000000000&quot; / &quot;FS/Z&quot;</div>
<div class="line">  &quot;6A898CC3-1DD2-11B2-99A6-080020736631&quot; / &quot;ZFS&quot;</div>
<div class="line">  &quot;EBD0A0A2-B9E5-4433-87C0-68B6B72699C7&quot; / &quot;ntfs&quot;</div>
<div class="line">  &quot;0FC63DAF-8483-4772-8E79-3D69D8477DE4&quot; / &quot;ext4&quot;</div>
<div class="line">  &quot;516E7CB6-6ECF-11D6-8FF8-00022D09712B&quot; / &quot;ufs&quot;</div>
<div class="line">  &quot;C91818F9-8025-47AF-89D2-F030D7000C2C&quot; / &quot;p9&quot;</div>
<div class="line">  &quot;D3BFE2DE-3DAF-11DF-BA40-E3A556D89593&quot; / &quot;Intel Fast Flash&quot;</div>
<div class="line">  &quot;21686148-6449-6E6F-744E-656564454649&quot; / &quot;BIOS boot&quot;</div>
<div class="line">     ...</div>
<div class="line">  &quot;77719A0C-A4A0-11E3-A47E-000C29745A24&quot; / &quot;VMware Virsto&quot;</div>
<div class="line">  &quot;9198EFFC-31C0-11DB-8F78-000C2911D1B8&quot; / &quot;VMware Reserved&quot;</div>
<div class="line">  &quot;824CC7A0-36A8-11E3-890A-952519AD3F61&quot; / &quot;OpenBSD data&quot;</div>
<div class="line">  &quot;CEF5A9AD-73BC-4601-89F3-CDEEEEE321A1&quot; / &quot;QNX6 file system&quot;</div>
<div class="line">  &quot;C91818F9-8025-47AF-89D2-F030D7000C2C&quot; / &quot;Plan 9 partition&quot;</div>
<div class="line">  &quot;5B193300-FC78-40CD-8002-E86C45580B47&quot; / &quot;HiFive Unleashed FSBL&quot;</div>
<div class="line">  &quot;2E54B353-1271-4842-806F-E436D6AF6985&quot; / &quot;HiFive Unleashed BBL&quot;</div>
<div class="line">  ...or any non-zero GUID in the form &quot;%08X-%04X-%04X-%04X-%12X&quot;</div>
</div><!-- fragment --><p>If <code>file</code> given, then the partition is filled with data from that file. If <code>size</code> is not given or smaller than the file's size, then the file's size will be the partition's size. If both given, and <code>size</code> is larger, then the difference is filled up with zeros. Partition sizes will always be multiple of <code>align</code> Kilobytes. Using 1024 as alignment gives you 1 Megabyte aligned partitions. For the first entry, only <code>size</code> is valid, <code>file</code> isn't. Alternatively to <code>file</code>, you might also be able to use <code>directory</code> to generate the partition image from the contents of a directory. This option is only available if the file system driver is implemented for <code>type</code>. Because there might be no one-to-one relation between partition types and file system types, you can use <code>driver</code> to explicily set the latter. This is only relevant when the <code>directory</code> directive is used. For example: </p><div class="fragment"><div class="line">{ &quot;type&quot;: &quot;5A2F534F-8664-5346-2F5A-000075737200&quot;, &quot;driver&quot;: &quot;FS/Z&quot;,  &quot;size&quot;: 32, &quot;name&quot;: &quot;usr&quot;,  &quot;directory&quot;: &quot;myusr&quot; },</div>
<div class="line">{ &quot;type&quot;: &quot;Linux home&quot;,                           &quot;driver&quot;: &quot;minix&quot;, &quot;size&quot;: 32, &quot;name&quot;: &quot;home&quot;, &quot;directory&quot;: &quot;myhome&quot; },</div>
<div class="line">{ &quot;type&quot;: &quot;Microsoft basic data&quot;,                 &quot;driver&quot;: &quot;fat&quot;,   &quot;size&quot;: 32, &quot;name&quot;: &quot;data&quot;, &quot;directory&quot;: &quot;mydata&quot; },</div>
</div><!-- fragment --><p>Finally, <code>name</code> is just an UTF-8 string, name of the partition. Maximum length is 35 characters. Not valid for the first entry.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Adding More File Systems</h1>
<p>Types are listed in the fs registry, in the file <code>fs.h</code>. You can freely add new file system types. For file systems that you want to use for generating partition images or initrd as well, you must implement three functions, like:</p>
<div class="fragment"><div class="line">void somefs_open(gpt_t *gpt_entry);</div>
<div class="line">void somefs_add(struct stat *st, char *name, unsigned char *content, int size);</div>
<div class="line">void somefs_close();</div>
</div><!-- fragment --><p>The first, the "open" is called whenever a new file system is to be created. The <code>gpt_entry</code> is NULL when called for initrd creation. As the given directory is recursively parsed, for each directory entry an "add" call is made. This should add the file or directory to the file system image. Here <code>st</code> is the stat struct for the file, <code>name</code> is the filename with full path, <code>content</code> and <code>size</code> are the file's content, or in case of a symbolic link, the pointed path. Finally when the parsing is done, the "close" function is called to finalize the image. Only the "add" function is mandatory, the other two are optional.</p>
<p>These functions can use two global variables, <code>fs_base</code> and <code>fs_len</code> which holds the buffer for the filesystem image in memory (this implies that partitions are limited to few gigabytes, depending how much RAM you have). In case they want to report error, <code>fs_no</code> is the number of the partition the driver is generating for.</p>
<p>In lack of these functions, the file system still can be used in the partition's <code>type</code> field, but then only the GPT entry will be created, not the content of the partition. The <code>driver</code> field only accepts file system types which have these functions.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Keeping the built-in binaries up-to-date</h1>
<p>To avoid dependencies, the image creator includes all the necessary binaries. If these are updated, then delete data.c and run <code>make</code> which will regenerate it. If there are missing files, then in the <code>aarch64-rpi</code> directory run <code>make getfw</code>, that will download the latest Raspberry Pi firmware files. Then <code>make</code> in this directory should run without problems. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
